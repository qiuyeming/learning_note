# 批处理
## 命令

### for
/F
**FOR /F ["options"] %%i IN (file) DO command**

**FOR /F ["options"] %%i IN ("string") DO command**

**FOR /F ["options"] %%i IN ('command') DO command**

这个可能是最常用的，也是最强的命令，主要用来处理文件和一些命令的输出结果。

file代表一个或多个文件

string 代表字符串

command代表命令

["options"] 可选

对于FOR /F %%i IN (file) DO command

file为文件名，按照官方的说法是，for会依次将file中的文件打开，并且在进行到下一个文件之前将每个文件读取到内存，按照每一行分成一个一个的元素，忽略空白的行，看个例子。

假如文件a.txt中有如下内容：

**第1行第1列 第1行第2列 第1行第3列
第2行第1列 第2行第2列 第2行第3列
第3行第1列 第3行第2列 第3行第3列**

你想显示a.txt中的内容，会用什么命令呢？当然是type，type a.txt

for也可以完成同样的命令：

for /f %%i in (a.txt) do echo %%i

还是先从括号执行，因为含有参数/f,所以for会先打开a.txt，然后读出a.txt里面的所有内容，把它作为一个集合，并且以每一行作为一个元素，所以会产生这样的集合，

**{“第1行第1列 第1行第2列 第1行第3列”， //第一个元素**

**“第2行第1列 第2行第2列 第2行第3列”， //第二个元素**

**“第3行第1列 第3行第2列 第3行第3列”}   //第三个元素**

集合中只有3个元素，同样用%%i依次代替每个元素，然后执行do后面的命令。

具体过程：

**用%%i代替“第1行第1列 第1行第2列 第1行第3列”，执行do后面的echo %%i，显示“第1行第1列 第1行第2列 第1行第3列”，**

**用%%i代替“第2行第1列 第2行第2列 第2行第3列”，执行echo %%i，显示“第2行第1列 第2行第2列 第2行第3列”，**

**依次，直到每个元素都代替完为止。**

为了加强理解/f的作用，请执行一下两个命令，对比即可明白：

**for /f %%i in (a.txt) do echo %%i //这个会显示a.txt里面的内容，因为/f的作用，会读出a.txt中 
的内容。**

for %%i in (a.txt) do echo %%i  //而这个只会显示a.txt这个名字，并不会读取其中的内容。**

通过上面的学习，我们发现for /f会默认以每一行来作为一个元素，但是如果我们还想把每一行再分解更小的内容，该怎么办呢？不用担心，for命令还为我们提供了更详细的参数，使我们将每一行分为更小的元素成为可能。

它们就是：**delims和tokens**

delims 用来告诉for每一行应该拿什么作为分隔符，默认的分隔符是空格和tab键

比如，还是上面的文件，我们执行下面的命令：

**for /f "delims= " %%i in (a.txt) do echo %%i**

显示的结果是：

**第1行第1列
第2行第1列
第3行第1列**

为什么是这样的呢。因为这里有了delims这个参数，=后面有一个空格，意思是再将每个元素以空格分割，默认是只取分割之后的第一个元素。

执行过程是：

**将第一个元素“第1行第1列 第1行第2列 第1行第3列”分成三个元素：“第1行第1列” “第1行第2列” “第1行第3列”，它默认只取第一个，即“第1行第1列”，然后执行do后面的命令，依次类推。**

但是这样还是有局限的，如果我们想要每一行的第二列元素，那又如何呢？

这时候，**tokens**跳出来说，我能做到。

它的作用就是当你通过delims将每一行分为更小的元素时，由它来控制要取哪一个或哪几个。

还是上面的例子，执行如下命令：

**for /f "tokens=2 delims= " %%i in (a.txt) do echo %%i**

执行结果：

**第1行第2列
第2行第2列
第3行第2列**

如果要显示第三列，那就换成tokens=3。

同时tokens支持通配符*，以及限定范围。

如果要显示第二列和第三列，则换成tokens=2,3或tokens=2-3,如果还有更多的则为：tokens=2-10之类的。

此时的命令为：

**for /f "tokens=2,3 delims= " %%i in (a.txt) do echo %%i %%j**

**怎么多出一个%%j？**

这是因为你的tokens后面要取每一行的两列，用%%i来替换第二列，用%%j来替换第三列。

并且必须是按照英文字母顺序排列的，%%j不能换成%%k，因为i后面是j

执行结果为：

**第1行第2列 第1行第3列
第2行第2列 第2行第3列
第3行第2列 第3行第3列**

对以通配符*，就是把这一行全部或者这一行的剩余部分当作一个元素了。

比如：

**for /f "tokens=* delims= " %%i in (a.txt) do echo %%i**

执行结果为：

**第1行第1列 第1行第2列 第1行第3列
第2行第1列 第2行第2列 第2行第3列
第3行第1列 第3行第2列 第3行第3列**

其实就跟for /f %%i in (a.txt) do echo %%i的执行结果是一样的。

再如：

**for /f "tokens=2,* delims= " %%i in (a.txt) do echo %%i %%j**

执行结果为：

**第1行第2列 第1行第3列
第2行第2列 第2行第3列
第3行第2列 第3行第3列**

用%%i代替第二列，用%%j代替剩余的所有

最后还有skip合eol，这俩个简单，skip就是要忽略文件的前多少行，而eol用来指定当一行以什么符号开始时，就忽略它。

比如：

**for /f "skip=2 tokens=*" %%i in (a.txt) do echo %%i**

结果为:

**第3行第1列 第3行第2列 第3行第3列**

用skip来告诉for跳过前两行。

如果不加tokens=*的话，执行结果为：

**第3行第1列**

不知道怎么回事。

再如，当a.txt内容变成：

**.第1行第1列 第1行第2列 第1行第3列
.第2行第1列 第2行第2列 第2行第3列
第3行第1列 第3行第2列 第3行第3列**

执行**for /f "eol=. tokens=*" %%i in (a.txt) do echo %%i**结果是：

**第3行第1列 第3行第2列 第3行第3列**

用eol来告诉for忽略以“.”开头的行。

同样也必须加tokens=*，否则只会显示“第3行第1列”


### 输出到nul
1>nul 意思是不显示命令运行的正确提示
2>nul 是不显示错误提示
一起就是 正确错误的都不显示
\>是重定向符号
nul是空设备的意思
把提示输入到空设备就不显示了

## %*是用来指批处理文件传入的参数
 1\. %~[0-9]：是指去除了引号的命令行参数
		%~0指命令行本身，本例为Batch\test 

 %~1指第一个参数，本例为C:\Program Files\studying.txt
                    注：%1也指第一个参数，本例却为“C:\Program Files\studying.txt”，这里是有引号的。

                    以此类推......

        2\.  %~f[0-9]：f - full，指绝对路径名

                  本例中：%~f0 - F:\Temp\Batch\test.bat

                                  %~f1 - C:\Program Files\studying.txt

        3. %~d[0-9]：d - driver，指盘符

                  本例中：%~d0 - F:

                                  %~d1 - C:

        4. %~p[0-9]：p - path，指不带盘符的目录名

                  本例中：%~p0 - \Temp\Batch\    注:前后都有'\'

                                  %~p1 - \Program Files\

        5. %~n[0-9]：n - name，指文件的名字，注意不带扩展名

                  本例中：%~n0 - test

                                  %~n1 - studying

        6. %~x[0-9]：x - extension，指文件的扩展名

                  本例中：%~x0 - .bat   注:前面有'.'

                                  %~x1 - .txt

        7. %~s[0-9]：s - short，指带有DOS短名字（8字符）的绝对路径

                  本例中：%~s0 - F:\TEMP\BATCH\test.bat  

                                  %~s1 - C:\PROGRA~1\studying.txt

                                  注:这里的目录名全是大写，而文件名全是小写

        8. %~a[0-9]：a - attribute，指文件的属性

                  本例中：%~a0 - --a-------  

                                  %~a1 - --a-------

                                  注：这里每一位代表一种文件属性，具体的含义我也不知道，待查

        9. %~t[0-9]：t - time，指文件的修改日期，注意不是创建日期

                  本例中：%~t0 - 2011-08-28 11:47  

                                  %~t1 - 2011-08-28 10:30

        10. %~z[0-9]：z - size，指文件的大小

        11. %~$PATH:[0-9]：PATH 指系统环境变量的那个PATH。搜索PATH里面的目录，看是否能够找到命令行参数指定的文件。找到此文件，输出该文件的绝对路径；没有找到此文件，输出空字符串。

        12\. 组合使用：上述的这些字符规则是可以组合起来使用的。例如，n和x组合表示带扩展名的文件名名字。

                                  %~nx0 - test.bat

                                  %~nx1 - studying.txt

        回到标题给出的问题，我们可以推测出%~dp0表示的意思。d表示盘符，p表示不带盘符的路径，那么dp就表示带盘符的路径了。


