# 数组要点
* <font color=#0099ff size=15 face="黑体">数组长度必须是非负整型常量表达式，长度是类型的组成部分。即元素类型相同，长度不同的数组不是同一类型
</font>
	```
	a := [4]int{1,3:7}   // 指定索引位置初始化
	b := [...]int{1,2,3} // 编译器按初始化值数量确定数组长度
	c := [...]int{3,3:12} // 支持索引初始化，但注意数组长度与此相关
	
	打印结果：
	>> [1 0 0 7]
	   [1 2 3]
	   [3 0 0 12]
	-------------------------------------
	
	对于结构等复合类型，可以省略初始化类型标签
	type user struct {
		name string
		age int
	}
	 t := [...]user{
	 	{"a",1},  //省略了user类型标签
	 	user{"b",2},
	 }
	-------------------------------------
	定义多位数组时，仅第一维度允许使用 "..."
	b := [...][2]int{
	 	{10,20},
	 	{30,40},
	 }
	
	-------------------------------------
	内置函数len,cap都返回第一维度长度
	-------------------------------------
	如果元素类型支持“==，!=”操作符，那么数组也支持此操作	
	------------------------------------
	x, y := 10, 20
	a := [...]*int{&x, &y} //指针数组：元素为指针类型
	p := &a                //数组指针：指向数组的指针
	
	```
 
## 复制
与C数组变量隐式作为指针使用不同，Go数组时值类型，赋值和传参操作都会复制整个数组数据
如果需要，可改用指针或切片，以避免数据复制
```
func main() {
	a :=[2]int{10,20}
	test1(&a)
	test2(a[:])
	fmt.Printf("a:%p,%v\n",&a,a)
}
//传指针
func test1(x *[2]int) {
	fmt.Printf("x:%p,%v\n",x,*x)
	x[1]+=100
}
//传切片
func test2(x2 []int)  {
	fmt.Printf("x2:%p,%v\n",x2,x2)
	x2[1]+=200
}

>>x:0xc04200a0d0,[10 20]
  x2:0xc04200a0d0,[10 120]
  a:0xc04200a0d0,[10 320]

```
# 切片
 切片内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。
 ```
 runtime包中slice结构
 type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

