# 反射
作用：让我们在运行期探知对象的类型信息和内存结构，从一定程度上弥补了go在静态语言在动态行为上的不足。同时反射还是实现元编程的重要手段

func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value

+ Type : 表示真实类型（静态类型）
+ Kind : 表示基础结构（底层类型）

底层Kind类型有：

	Bool | Int | Int8 | Int16 | Int32 | Int64
	--- |
	Uint|Uint8|Uint16|Uint32|Uint64|Uintptr
	Float32|Float64	|Complex64|Complex128|Array
	Chan|Func|Interface|Map|Ptr|Slice|String
	Struct|UnsafePointer

除通过实际对象获取类型外，可以通过反射直接构造一些基础复合类型
(目前感觉没什么用。。。)
```
s := reflect.ArrayOf(10, reflect.TypeOf("st"))
fmt.Println(s)
>>> [10]string
```

传入对象区分基类型和指针类型
```
	x := 100
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
     >>int *int false
       int ptr
       true  
       ------------------
       	x := make([]chan *struct{A string},0)
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
     >>[]chan *struct { A string } *[]chan *struct { A          string } false
       slice ptr
       true
```
方法Elem()返回指针，数组，切片，字典或通道的基类型
```
// Elem returns a type's element type.
// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.

```	

只有获取结构体指针的基类型后，才能遍历它的字段
```
type Person struct {
	Name string
	age  int `json:"age"`
}
func main() {
	x :=  Person{Name:"x"}
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
	fmt.Println("----")
	
	for i:=0;i<tx.NumField();i++ {
		fmt.Printf("第%d个字段",i)
		fmt.Println(tx.Field(i).Name)
		fmt.Println(tx.Field(i).Type)
		fmt.Println(tx.Field(i).Anonymous)
		fmt.Println(tx.Field(i).Index)
		fmt.Println(tx.Field(i).Offset)
		fmt.Println(tx.Field(i).PkgPath)
		fmt.Println(tx.Field(i).Tag)
	}
	
}
>>
	main.Person *main.Person false
	struct ptr
	true
	----
	第0个字段Name
	string
	false
	[0]
	0


	第1个字段age
	int
	false
	[1]
	16
	main
	json:"age"
	
```
访问匿名字段
1.通过多级索引直接访问
```
	// FieldByIndex returns the nested field corresponding
	// to the index sequence. It is equivalent to calling Field
	// successively for each index i.
	// It panics if the type's Kind is not Struct.
	FieldByIndex(index []int) StructField
```
2.通过字段进行访问

同样的输出方法集时，也区分基类型和指针类型

反射能探知当前包的非导出结构成员


# 值
Value 专注于对象实例数据的读写
接口变量会复制对象，而且是unaddressable的，所以要想修改目标对象，必须要使用指针
就算传入指针，一样需要Elem获取目标对象，因为被接口存储的指针本身是不能寻址和进行设置操作的。
```
// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if v's Kind is not Interface or Ptr.
// It returns the zero Value if v is nil.
```
不能对非导出字段直接进行设置操作，无论是当前包还是外包
```
type Person struct {
	Name string
	age  int `json:"age"`
}
func main() {
	p := Person{}
	va,vp := reflect.ValueOf(p),reflect.ValueOf(&p)
	//fmt.Println(va.Kind(),vp.Kind())
	//fmt.Println(va.Elem())
	_ = va
	vp = vp.Elem()
	
	for i:=0;i<vp.NumField();i++ {
		fmt.Println(vp.Field(i).CanAddr())
		fmt.Println(vp.Field(i).CanSet())
	}
	
	name := vp.FieldByName("Name")
	age := vp.FieldByName("age")
	value := reflect.ValueOf("ai")
	name.Set(value)
	fmt.Println(p)
	name.SetString("oi")
	fmt.Println(p)
	
	px := (*string)(unsafe.Pointer(age.UnsafeAddr()))
	fmt.Println(px,*px=="")
	*px = "12"
	fmt.Printf("%v",p)
	
	pint := (*int)(unsafe.Pointer(age.UnsafeAddr()))
	fmt.Println(pint,*pint)
	*pint = 12
	fmt.Printf("%v",p)
	
	age.Pointer() //返回point
	fmt.Println(age.Int()) //返回12
	
}
>>
	true
	true
	true
	false
	{ai 0}
	{oi 0}
	0xc0420023f0 true
	{oi 5098856}0xc0420023f0 5098856
	{oi 12}
```

PS：重要：可以通过Interface方法进行类型推断和转换

复合类型对象设置示例
```
chan
 	c := make(chan int)
	v := reflect.ValueOf(c)
	
	if v.TrySend(reflect.ValueOf(100)) {
		fmt.Println(v.TryRecv())
	}
map
	c := make(map[int]string)
	v := reflect.ValueOf(c)
	v.SetMapIndex(reflect.ValueOf(1),reflect.ValueOf("s"))
	fmt.Println(c)  //1:s
slice
	v.slice() 方法
```

接口的两种状态，解决方法是用IsNil判断值是否为nil
```
	var a interface{} = nil
	var b interface{} = (*int)(nil)
	fmt.Println(a == nil )  // true
	fmt.Println(b == nil,reflect.ValueOf(b).IsNil() ) //false,true
```

