	fmt.Println(len(s),cap(s))# 反射
作用：让我们在运行期探知对象的类型信息和内存结构，从一定程度上弥补了go在静态语言在动态行为上的不足。同时反射还是实现元编程的重要手段

func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value

+ Type : 表示真实类型（静态类型）
+ Kind : 表示基础结构（底层类型）

底层Kind类型有：

	Bool | Int | Int8 | Int16 | Int32 | Int64
	--- |
	Uint|Uint8|Uint16|Uint32|Uint64|Uintptr
	Float32|Float64	|Complex64|Complex128|Array
	Chan|Func|Interface|Map|Ptr|Slice|String
	Struct|UnsafePointer

除通过实际对象获取类型外，可以通过反射直接构造一些基础复合类型
(目前感觉没什么用。。。)
```
s := reflect.ArrayOf(10, reflect.TypeOf("st"))
fmt.Println(s)
>>> [10]string
```

传入对象区分基类型和指针类型
```
	x := 100
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
     >>int *int false
       int ptr
       true  
       ------------------
       	x := make([]chan *struct{A string},0)
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
     >>[]chan *struct { A string } *[]chan *struct { A          string } false
       slice ptr
       true
```
方法Elem()返回指针，数组，切片，字典或通道的基类型
```
// Elem returns a type's element type.
// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.

```	

只有获取结构体指针的基类型后，才能遍历它的字段
```
type Person struct {
	Name string
	age  int `json:"age"`
}
func main() {
	x :=  Person{Name:"x"}
	tx,tp := reflect.TypeOf(x),reflect.TypeOf(&x)
	
	fmt.Println(tx,tp,tx==tp)
	fmt.Println(tx.Kind(),tp.Kind())
	fmt.Println(tx == tp.Elem())
	fmt.Println("----")
	
	for i:=0;i<tx.NumField();i++ {
		fmt.Printf("第%d个字段",i)
		fmt.Println(tx.Field(i).Name)
		fmt.Println(tx.Field(i).Type)
		fmt.Println(tx.Field(i).Anonymous)
		fmt.Println(tx.Field(i).Index)
		fmt.Println(tx.Field(i).Offset)
		fmt.Println(tx.Field(i).PkgPath)
		fmt.Println(tx.Field(i).Tag)
	}
	
}
>>
	main.Person *main.Person false
	struct ptr
	true
	----
	第0个字段Name
	string
	false
	[0]
	0


	第1个字段age
	int
	false
	[1]
	16
	main
	json:"age"
	
```