在操作系统中，有两个重要的概念：一个是进程、一个是线程。当我们运行一个程序的时候，比如你的IDE或者QQ等，操作系统会为这个程序创建一个进程，这个进程包含了运行这个程序所需的各种资源，可以说它是一个容器，是属于这个程序的工作空间，比如它里面有内存空间、文件句柄、设备和线程等等。

那么线程是什么呢？线程是一个执行的空间，比如要下载一个文件，访问一次网络等等。线程会被操作系统调用，来在不同的处理器上运行编写的代码任务，这个处理器不一定是该程序进程所在的处理。操作系统过的调度是操作系统负责的，不同的操作系统可能会不一样，但是对于我们程序编写者来说，不用关心，因为对我们都是透明的。

一个进程在启动的时候，会创建一个主线程，这个主线程结束的时候，程序进程也就终止了，所以一个进程至少有一个线程，这也是我们在main函数里，使用goroutine的时候，要让主线程等待的原因，因为主线程结束了，程序就终止了，那么就有可能会看不到goroutine的输出。

go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。

这里我们总结下几个概念：

概念	说明
进程	一个程序对应一个独立程序空间
线程	一个执行空间，一个进程可以有多个线程
逻辑处理器	执行创建的goroutine，绑定一个线程
调度器	Go运行时中的，分配goroutine给不同的逻辑处理器
全局运行队列	所有刚创建的goroutine都会放到这里
本地运行队列	逻辑处理器的goroutine队列
当我们创建一个goroutine的后，会先存放在全局运行队列中，等待Go运行时的调度器进行调度，把他们分配给其中的一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中，最终等着被逻辑处理器执行即可。

Goroutines优于线程的优势
1.与线程相比，Goroutines非常便宜。它们的堆栈大小只有几kb，堆栈可根据应用程序的需要增长和缩小，而在线程的情况下，堆栈大小必须指定并固定。
2.Goroutines被多路复用到少量的OS线程。一个程序中可能只有一个线程，有数千个Goroutine。如果该线程中的任何Goroutine阻止了等待用户输入，则创建另一个OS线程，并将剩余的Goroutine移动到新的OS线程。所有这些都由运行时处理，我们作为程序员从这些复杂的细节中抽象出来，并给予一个干净的API来处理并发。
3.Goroutines使用渠道进行沟通。使用Goroutine访问共享内存时，通道设计可以防止竞争状况的发生。渠道可以被认为是Goroutines沟通的管道